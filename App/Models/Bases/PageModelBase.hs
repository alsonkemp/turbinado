{- DO NOT EDIT THIS FILE
   THIS FILE IS AUTOMAGICALLY GENERATED AND YOUR CHANGES WILL BE EATEN BY THE GENERATOR OVERLORD

   All changes should go into the Model file (e.g. App/Models/ExampleModel.hs) and
   not into the base file (e.g. App/Models/Bases/ExampleModelBase.hs) -}

module App.Models.Bases.PageModelBase ( 
 module App.Models.Bases.PageModelBase, 
 module App.Models.Bases.ModelBase) where

import App.Models.Bases.ModelBase
import qualified Database.HDBC as HDBC
import System.Time

data Page = Page {
    _id :: String,    authorId :: Maybe Int64,    content :: String,    title :: String,    version :: Int64
    } deriving (Eq, Show)

instance DatabaseModel Page where
    tableName _ = "page"

instance IsModel Page where
    insert conn m = do
        res <- liftIO $ HDBC.run conn " INSERT INTO page (_id,author_id,content,title,version) VALUES (?,?,?,?,?)"
                  [HDBC.toSql $ _id m , HDBC.toSql $ authorId m , HDBC.toSql $ content m , HDBC.toSql $ title m , HDBC.toSql $ version m]
        liftIO $ HDBC.commit conn
        i <- liftIO $ HDBC.catchSql (HDBC.quickQuery' conn "SELECT lastval()" []) (\_ -> HDBC.commit conn >> (return $ [[HDBC.toSql (0 :: Int)]]) ) 
        return $ HDBC.fromSql $ head $ head i
    findAll conn = do
        res <- liftIO $ HDBC.quickQuery' conn "SELECT _id , author_id , content , title , version FROM page" []
        return $ map (\r -> Page (HDBC.fromSql (r !! 0)) (HDBC.fromSql (r !! 1)) (HDBC.fromSql (r !! 2)) (HDBC.fromSql (r !! 3)) (HDBC.fromSql (r !! 4))) res
    findAllBy conn ss sp = do
        res <- liftIO $ HDBC.quickQuery' conn ("SELECT _id , author_id , content , title , version FROM page WHERE (" ++ ss ++ ") ")  sp
        return $ map (\r -> Page (HDBC.fromSql (r !! 0)) (HDBC.fromSql (r !! 1)) (HDBC.fromSql (r !! 2)) (HDBC.fromSql (r !! 3)) (HDBC.fromSql (r !! 4))) res
    findOneBy conn ss sp = do
        res <- liftIO $ HDBC.quickQuery' conn ("SELECT _id , author_id , content , title , version FROM page WHERE (" ++ ss ++ ") LIMIT 1")  sp
        return $ (\r -> Page (HDBC.fromSql (r !! 0)) (HDBC.fromSql (r !! 1)) (HDBC.fromSql (r !! 2)) (HDBC.fromSql (r !! 3)) (HDBC.fromSql (r !! 4))) (head res)
instance HasFindByPrimaryKey Page  (String)  where
    find conn pk@(pk1) = do
        res <- liftIO $ HDBC.quickQuery' conn ("SELECT _id , author_id , content , title , version FROM page WHERE (_id = ? )") [HDBC.toSql pk1]
        case res of
          [] -> throwDyn $ HDBC.SqlError
                           {HDBC.seState = "",
                            HDBC.seNativeError = (-1),
                            HDBC.seErrorMsg = "No record found when finding by Primary Key:page : " ++ (show pk)
                           }
          r:[] -> return $ Page (HDBC.fromSql (r !! 0)) (HDBC.fromSql (r !! 1)) (HDBC.fromSql (r !! 2)) (HDBC.fromSql (r !! 3)) (HDBC.fromSql (r !! 4))
          _ -> throwDyn $ HDBC.SqlError
                           {HDBC.seState = "",
                            HDBC.seNativeError = (-1),
                            HDBC.seErrorMsg = "Too many records found when finding by Primary Key:page : " ++ (show pk)
                           }

    update conn m = do
        res <- liftIO $ HDBC.run conn "UPDATE page SET (_id , author_id , content , title , version) = (?,?,?,?,?) WHERE (_id = ? )"
                  [HDBC.toSql $ _id m , HDBC.toSql $ authorId m , HDBC.toSql $ content m , HDBC.toSql $ title m , HDBC.toSql $ version m, HDBC.toSql $ _id m]
        liftIO $ HDBC.commit conn
        return ()
